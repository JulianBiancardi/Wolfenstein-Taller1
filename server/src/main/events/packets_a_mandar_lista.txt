Lista de Packets que se envían

/* Para comunicar movimientos
 * El cliente lo usa para pedir moverse.
 * El servidor lo usa para notificarte a donde te moviste (puede ser tu mismo lugar).
 * El servidor lo usa para notificar a todos si alguien se movio.
 * Client<->Server
 */
MOVE PACKET

int type: 1
int player_id: I
=====
sPoint point: X // El cliente pide moverse a (X,Y)
sPoint point: Y // El server le avisa al cliente donde se encuentra
=====


/* Para comunicar levantado de cosas.
 * Se puede recibir luego de moverse, disparar o ser disparado.
 * Si el player_id es el de uno mismo, se aplica. 
 * Siempre se borra del mapa del cliente el item.
 * Client<-Server
 */
GRAB PACKET

int type: 2
int player_id: I
int item_id: X


/* Para comunicar disparos acertados.
 * Si el disparado no muere se le manda un paquete de DAMAGE
 * (solo a él, los otros clientes NO conocen sus puntos de vida).
 * Si el disparado muere se manda un paquete de KILL a todos los jugadores.
 * Client->Server
 */
SHOT HIT PACKET

int type: 3
int player_id: I // Id del que dispara
=====
sShoot damage_done: X
sShoot enemy_shot: Y // Id del disparado
sShoot bullets_shot: Z // La cantidad de balas se envia porque el server
=====                  // no sabe cuanto gasta cada arma


/* Para comunicar disparos no acertados.
 * Client->Server
 */
SHOT MISS PACKET

int type: 4
int player_id: I // Id del que dispara
int bullets_shot: X


/* Para comunicar daños a un jugador
 * El servidor lo usa para notificar que le quitaron vida.
 * Solo es notificado el jugador que recibe daño
 * (el cliente no conoce los puntos de vida del resto).
 * Solo nace como consecuencia de un disparo acertado.
 * Client<-Server
 */
DAMAGE PACKET

int type: 5
int player_id: I
double damage: X


/* Para comunicar cambio de arma
 * Los clientes son notificados de que el jugador I cambio de arma para
 * actualizar el sprite.
 * Client<->Server
 */
CHANGE GUN PACKET

int type: 6
int player_id: I
int gun: X


/* Para comunicar asesinato
 * Es consecuencia de un disparo acertado.
 * El cliente es el encargado de: hacer que respawnee el jugador (si debe) o eliminarlo.
 * Tambien deberá hacer que spawnee en su mapa el drop que deja la muerte.
 * Este último * puede ser reemplazado con paquetes ADD ITEM.
 * Client<-Server
 */
KILL PACKET

int type: 7
int player_id: I
int killer: X


/* Para comunicar que ya respawneo el jugador
 * Nace solo luego de un paquete de KILL y lo genera el cliente que fue asesindo.
 * Sirve para ignorar movimientos acumulados previos a que fuese asesinado
 * (paquetes no procesados todavía por el servidor de MOVE del jugador ya asesinado).
 * Evita teletransportaciones de jugadores.
 * Client->Server
 */
RESPAWN PACKET

int type: 8
int player_id: I


/* Para hacer que el keep_running del match sea false cuando se utiliza una cola bloqueante
 * Se usa internamente en el server.
 * Cuando el reloj llega a 0 o no quedan jugadores se encola este paquete.
 * Sirve para forzar a que el juego termine cuando la cola este bloqueada.
 * Parecido a la excepcion que lanza el accept de socket.
 * Server
 */
GAME OVER PACKET

int type: 9


Lista de Packets que se envían todavia NO IMPLEMENTADOS


/* Para comunicar puertas abiertas/cerradas
 * El cliente lo usa para avisar que interactuó con una puerta
 * El servidor lo usa para avisar que interactuaron con una puerta
 * Client<->Server
 */ 
MAP PACKET

int type: TODO
sPoint door_pos: X 


/* Para anunciar fin de la conexión
 * Client<->Server
 */
DISCONNECTION PACKET

int type: TODO


/* Para anunciar una nueva conexión y solicitar un id
 * Client->Server
 * Server->Client
 */
CONNECTION PACKET

int type: TODO
=====
int player_id: 0 // Al pedir al server
int player_id: X // Al recibir del server
=====


/* Para rotaciones
 * Client<->Server
 */
ROTATION PACKET

int type: TODO
int player_id: I
double angle: X // Angulo en el que el jugador quiere quedar respecto al semieje positivo X

